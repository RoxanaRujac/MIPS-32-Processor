 			 B"000000_00000_00000_00001_00000_000110",	    	--0:	xor	$1, $0, $0	 X"00000806"	
                         B"000010_00000_00010_0000000000001000",		--1:	lw  	$2, 8($0) 	 X"08020008"
                         B"000010_00000_00011_0000000000000100",		--2:	lw  	$3, 4($0)	 X"08030004"	
                         B"000010_00000_00100_0000000000000000",		--3:	lw  	$4, 0($0)	 X"08040000"
                         B"000001_00000_00101_0000000000000000",	   	--4:	addi 	$5, $0, 0	 X"04050000"
                                                                        	--bucla
                         B"000100_00001_00011_0000000000001010",		--5:	beq 	$1, $3, 10	 X"1023000A" 
                         B"000010_00101_00110_0000000000001100",		--6:	lw  	$6, 12($5)	 X"08A6000C"	
                         B"000001_00000_00111_0000000000000001",		--7:	addi 	$7, $0, 1	 X"04070001"
                         B"000000_00110_00111_01000_00000_000100",	    	--8:	and 	$8, $6, $7	 X"00C74004"	
                         B"000100_01000_00000_0000000000000011",		--9:	beq 	$8, $0, 3	 X"11000003"	
                         B"000000_00110_00010_01001_00000_000111",	    	--10:	slt 	$9, $6, $2	 X"00C24807" 
                         B"000100_01001_00000_0000000000000001",		--11:	beq 	$9, $0, 1	 X"11200001"	
                         B"000000_00110_00000_00010_00000_000000",		--12:	add 	$2, $6, $0	 X"00C01000"
                         B"000001_00001_00001_0000000000000001",		--13:	addi 	$1, $1, 1	 X"04210001"
                         B"000001_00101_00101_0000000000000100",		--14:	addi 	$5, $5, 4	 X"04A50004"
                                                                        	--afara
                         B"000111_00000000000000000000000101",		    	--15:	j 	5		 X"01C000005"
                         B"000011_00000_00010_0000000000001000",		--16:	sw 	$2, 8($0)	 X"00C020008"	




------------------------------------------------------------------------------------------------------------------------------------------------------------



0:	xor 	$1, $0, $0		--initializarea contorului cu 0
1:	lw  	$2, 8($0) 	 	--initializez minimul impar cu cel mai mare numar
2:	lw  	$3, 4($0)		--am citit n de la adresa 4 (numarul de numere stocate)
3:	lw  	$4, 0($0)		--citesc adresa de inceput a sirului A de la adresa 0 (pointer spre inceputul sirului)
4:	addi 	$5, $0, $0		--folosesc $5 pentru a parcurge sirul ($5 - indexul sirului, A[index])

--bucla

5:	beq 	$1, $3, 10		--verific daca contorul <= n si daca nu sar la finalul buclei
6:	lw  	$6, 12($5)		--luam elementul curent $6 = A[index]
7:	addi 	$7, $0, 1		--incarc valoarea 1 in registrul 7
8:	and 	$8, $6, $7		--and intre numarul curent si valoarea 1 in $8
9:	beq 	$8, $0, 3		--daca rezultatul din $8 e 0 atunci e nr par sarim la instructiunile de incrementare
10:	slt 	$9, $6, $2		--verifica daca numarul actual (impar) e mai mic decat minimul actual
11:	beq 	$9, $0, 1		--daca nr nu este mai mic decat minimul curent sarim la instructiunile de incrementare
12:	add 	$2, $6, $0		--salvam minimul curent in $2
13:	addi 	$1, $1, 1		--incrementam contorul
14:	addi 	$5, $5, 4 		--actualizam pozitia din sir

--afara

15:	j 	5			--revine la inceputul buclei
16:	sw 	$2, 8($0)		--pune in memorie la adresa 8 rezultatul -> minimul impar

